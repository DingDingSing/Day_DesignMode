### 排序算法

#### O(n2)
- 插入排序
- 冒泡排序
- 选择排序

#### O(nlogn)
- 归并排序
- 快速排序

##### O(n)
- 桶排序
- 计数排序
- 基数排序


#### 如何分析排序算法

##### 算法执行效率
https://time.geekbang.org/column/article/41802
- 最好、最坏、平均时间复杂度
  - 平均时间复杂度 加权平均
    - 有序度是数组中具有有序关系的元素对的个数
      - 对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。
    - 逆序度的定义正好跟有序度相反（默认从小到大为有序）
    - 我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。
  - 冒泡排序
    - 冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。
    - 对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。
    - 换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。
- 时间复杂度系数、常数、低阶
- 比较和交换次数

##### 算法内存消耗

- 原地排序 O(1)

##### 算法排序稳定性

- 这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。